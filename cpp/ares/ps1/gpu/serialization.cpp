auto GPU::serialize(serializer& s) -> void {
  Thread::serialize(s);

  s(vram);

  s(display.dotclock);
  s(display.width);
  s(display.height);
  s(display.interlace);
  s(display.previous.x);
  s(display.previous.y);
  s(display.previous.width);
  s(display.previous.height);

  s((u32&)io.mode);
  s(io.field);
  s(io.hcounter);
  s(io.vcounter);
  s(io.pcounter);
  s(io.copy.x);
  s(io.copy.y);
  s(io.copy.width);
  s(io.copy.height);
  s(io.copy.px);
  s(io.copy.py);
  s(io.texturePageBaseX);
  s(io.texturePageBaseY);
  s(io.semiTransparency);
  s(io.textureDepth);
  s(io.dithering);
  s(io.drawToDisplay);
  s(io.textureDisable);
  s(io.textureFlipX);
  s(io.textureFlipY);
  s(io.textureWindowMaskX);
  s(io.textureWindowMaskY);
  s(io.textureWindowOffsetX);
  s(io.textureWindowOffsetY);
  s(io.drawingAreaOriginX1);
  s(io.drawingAreaOriginY1);
  s(io.drawingAreaOriginX2);
  s(io.drawingAreaOriginY2);
  s(io.drawingAreaOffsetX);
  s(io.drawingAreaOffsetY);
  s(io.forceMaskBit);
  s(io.checkMaskBit);
  s(io.interrupt);
  s(io.displayDisable);
  s(io.dmaDirection);
  s(io.displayStartX);
  s(io.displayStartY);
  s(io.displayRangeX1);
  s(io.displayRangeY1);
  s(io.displayRangeX2);
  s(io.displayRangeY2);
  s(io.horizontalResolution);
  s(io.verticalResolution);
  s(io.videoMode);
  s(io.colorDepth);
  s(io.interlace);
  s(io.reverseFlag);
  s(io.status);
  s(io.texturePaletteX);
  s(io.texturePaletteY);

  s(queue.gp0.command);
  s(queue.gp0.length);
  s(queue.gp0.data);
  s(queue.gp0.counterX);
  s(queue.gp0.counterY);
  s(queue.gp1.command);
  s(queue.gp1.length);
  s(queue.gp1.data);
  s(queue.gp1.counterX);
  s(queue.gp1.counterY);

  renderer.power();
}
